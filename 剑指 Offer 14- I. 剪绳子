一、问题描述：剑指 Offer 14- I. 剪绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

提示：2 <= n <= 58


二、思路分析
（1）方法一：找规律   
这个思路摘自 作者：xiao-bai-323 （虽然我也想到了，但是别人给的全一点）

首先把题目抽丝剥茧，题目套了个剪绳子的壳子。其实就是数字n，如何分解保证乘积最大。不妨举几个例子：

第一步：定义dp[n]的值的含义为：数字n的乘积最大值
n=2:  1+1  -->1*1=1;   				dp[2]=1;
n=3:  2+1  -->2*1=2;   				dp[3]=2;
n=4:  2+2  -->2*2=4;   				dp[4]=4;
n=5:  3+2  -->3*2=6;   				dp[5]=6;
貌似看不出规律，别急再多写几个
n=6:  3+3  -->3*3=4;                 dp[6]=9;
n=7:  4+3  -->4*3=12;-->dp[4]*3=12   dp[7]=12;
n=8:  5+3  -->6*3=12;-->dp[5]*3=18   dp[8]=18;
n=9:  6+3  -->9*3=12;-->dp[6]*3=27   dp[9]=27;
n=10: 7+3  -->12*3=36;-->dp[7]*3=12   dp[10]=36;

第二步：找到递推的规律：

通过上述分析，规律明显在n=7以后为

if(n>=7)
	dp[n] = dp[n-3]*3;
  
第三步：找初始值：

初始值在第二步找规律已经找到了，即
n=2:  1+1  -->1*1=1;   				dp[2]=1;
n=3:  2+1  -->2*1=2;   				dp[3]=2;
n=4:  2+2  -->2*2=4;   				dp[4]=4;
n=5:  3+2  -->3*2=6;   				dp[5]=6;
n=6:  3+3  -->3*3=4;                dp[6]=9;

通过以上分析，就直接可以写代码了：


（2）方法二：动态规划
第一步：// n<=3的情况，m>1必须要分段，例如：3必须分成1、2；1、1、1   
        //因此n=3最大分段乘积是2, 同理2的最大乘积为1
        if (n == 2)
            return 1;
        if (n == 3)
            return 2;

第二步： 下面是n>=4的情况，跟n<=3不同，4可以分很多段，比如分成1、3，
        而3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。

第三步： 我要分析j<=i/2，是因为1*3和3*1是一样的，没必要计算在内，只要计算到1*3和2*2就好了


三、代码
class Solution {
    public int cuttingRope(int n) {
        //方法一：找规律 从n=7开始，与n-3是存在3倍关系的
        /*
        //1.创建数组-设置对应的含义,dp[n]为长度为 n 时候，最大的乘积 我们只需求出dp[n]
        int[] dp = new int[n+7];
        //3.确定初始值
        dp[0]=0;
        dp[1]=0;
        dp[2]=1;
        dp[3]=2;
        dp[4]=4;
        dp[5]=6;
        dp[6]=9;
        if(n<=6){return dp[n];}
        //2.找到递推关系
        for (int i = 7; i <= n; i++) {
            dp[i] = dp[i-3]*3;
        }
        return dp[n];
        */


        //方法二：动态规划
        int[] dp = new int[n+1];
        // n<=3的情况，m>1必须要分段，例如：3必须分成1、2；1、1、1   
        //因此n=3最大分段乘积是2, 同理2的最大乘积为1
        if (n == 2)
            return 1;
        if (n == 3)
            return 2;
        
        /*
        下面是n>=4的情况，跟n<=3不同，4可以分很多段，比如分成1、3，
        而3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。
        */
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for(int i =4;i<=n;i++) {
            int maxValue = 0;  //记录后面的最大值
            //j<=i/2是因为1*3和3*1是一样的，没必要计算在内，只要计算到1*3和2*2就好了
            for(int j = 1;j<=i/2;j++) {
                maxValue = Math.max(maxValue,dp[j] * dp[i-j]);
            }
            dp[i] = maxValue;
        }
        return dp[n];
    }
}
